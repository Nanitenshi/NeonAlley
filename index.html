<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#05070a" />
  <title>NEON ALLEY — Hybrid Overworld Prototype</title>

  <!-- PWA (optional, du hast manifest.webmanifest & sw.js schon im Repo) -->
  <link rel="manifest" href="./manifest.webmanifest">
  <link rel="icon" href="./icon-192.png">

  <style>
    :root{
      --bg:#05070a;
      --panel: rgba(10,16,24,.90);
      --line: rgba(0,243,255,.22);
      --cyan:#00f3ff;
      --pink:#ff007c;
      --yellow:#fcee0a;
      --text:#d9e7ee;
      --muted:#8aa0b3;
      --shadowC: 0 0 22px rgba(0,243,255,.28);
      --shadowP: 0 0 22px rgba(255,0,124,.22);
      --font: ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace;
    }

    html,body{
      margin:0; height:100%;
      background: var(--bg);
      color: var(--text);
      font-family: var(--font);
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    /* ==== LAYERING (Klick-Fix) ==== */
    #app{ position:relative; height:100%; width:100%; }
    #worldCanvas{
      position:absolute; inset:0;
      display:block;
      z-index:0;                 /* Canvas hinten */
      background: radial-gradient(circle at 50% 40%, rgba(0,243,255,.06), transparent 55%),
                  radial-gradient(circle at 20% 80%, rgba(255,0,124,.06), transparent 55%),
                  linear-gradient(180deg, rgba(7,10,16,.0), rgba(0,0,0,.45));
      touch-action:none;         /* Drag auf Canvas ok */
    }
    #ui{
      position:absolute; inset:0;
      z-index:10;                /* UI immer vorne */
      pointer-events:auto;       /* UI ist klickbar */
    }

    /* Scanlines */
    #ui::before{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      background: repeating-linear-gradient(to bottom, rgba(255,255,255,.02) 0 1px, transparent 1px 4px);
      opacity:.25;
      mix-blend-mode:screen;
    }

    /* Panels */
    .panel{
      background: linear-gradient(180deg, rgba(10,16,24,.92), rgba(5,9,14,.92));
      border:1px solid rgba(0,243,255,.25);
      box-shadow: var(--shadowC);
      backdrop-filter: blur(6px);
      border-radius: 12px;
    }
    .panel.pink{ border-color: rgba(255,0,124,.28); box-shadow: var(--shadowP); }

    /* HUD */
    #hud{
      position:absolute; left:12px; right:12px; top:10px;
      display:flex; gap:10px; align-items:stretch; justify-content:space-between;
      pointer-events:none;
    }
    #hud .left, #hud .right{ display:flex; gap:10px; align-items:stretch; }
    .chip{
      pointer-events:none;
      padding:10px 12px;
      min-width:120px;
      border-radius:12px;
      font-size:12px;
      letter-spacing:.5px;
      color:var(--muted);
    }
    .chip b{ color:var(--text); font-size:14px; }

    /* Main card */
    #centerWrap{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:14px;
    }
    #card{
      width:min(920px, 95vw);
      padding:16px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }

    #logo{
      text-align:center;
      font-size:34px;
      font-weight:900;
      letter-spacing:6px;
      color:var(--cyan);
      text-shadow: 0 0 16px rgba(0,243,255,.35);
      margin-top:6px;
    }
    #sub{
      text-align:center;
      font-size:12px;
      letter-spacing:2px;
      color:var(--pink);
      opacity:.95;
      margin-top:-6px;
    }
    #desc{
      font-size:12px;
      line-height:1.6;
      color: #cfe0eb;
      opacity:.95;
      text-align:center;
      margin: 0 6px;
    }

    /* Buttons */
    .row{ display:flex; gap:12px; flex-wrap:wrap; justify-content:center; }
    .btn{
      appearance:none;
      border:1px solid rgba(0,243,255,.55);
      background: rgba(0,0,0,.22);
      color: var(--cyan);
      padding:12px 14px;
      font-weight:900;
      letter-spacing:1px;
      text-transform:uppercase;
      border-radius:12px;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
    }
    .btn:hover{ background: rgba(0,243,255,.10); }
    .btn:active{ transform: translateY(1px); }
    .btn.yellow{ border-color: rgba(252,238,10,.55); color: var(--yellow); }
    .btn.pink{ border-color: rgba(255,0,124,.55); color: var(--pink); }

    /* Overworld overlay */
    #overworld{
      position:absolute; left:12px; top:70px; width:min(440px, 92vw);
      padding:12px;
      display:none;
    }
    #overworld h3{
      margin:0 0 8px 0;
      font-size:12px;
      color: var(--cyan);
      letter-spacing:2px;
      text-transform:uppercase;
    }
    #overworld .tiny{ font-size:11px; color: var(--muted); line-height:1.4; }

    /* NPC panel */
    #npcPanel{
      position:absolute; right:12px; top:70px; width:min(420px, 92vw);
      padding:12px;
      display:none;
    }
    #npcPanel h3{
      margin:0 0 8px 0;
      font-size:12px;
      letter-spacing:2px;
      text-transform:uppercase;
      color: var(--pink);
    }
    #npcText{ font-size:12px; line-height:1.55; color:#cfe0eb; }

    /* Log / footer */
    #log{
      margin-top:6px;
      font-size:11px;
      color:var(--muted);
      border-top:1px solid rgba(0,243,255,.14);
      padding-top:8px;
    }
    #footerBar{
      position:absolute; left:12px; right:12px; bottom:10px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px;
      pointer-events:none;
    }
    #quote{ font-size:12px; color:#cfe0eb; opacity:.95; pointer-events:none; }
    #footerBtns{ display:flex; gap:10px; pointer-events:auto; }
    #toast{
      position:absolute; left:50%; bottom:64px; transform:translateX(-50%);
      padding:10px 12px;
      border-radius:12px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(0,243,255,.25);
      box-shadow: var(--shadowC);
      font-size:12px;
      color:var(--text);
      display:none;
      pointer-events:none;
    }

    @media (max-width: 900px){
      #overworld, #npcPanel{ width: min(92vw, 520px); }
      #npcPanel{ top: auto; bottom: 86px; }
    }
  </style>
</head>

<body>
  <div id="app">
    <canvas id="worldCanvas"></canvas>

    <div id="ui">
      <div id="hud">
        <div class="left">
          <div class="chip panel">
            DISTRICT<br><b id="district">Sector-07</b>
          </div>
        </div>
        <div class="right">
          <div class="chip panel">EDDIES<br><b id="money">E$ 0</b></div>
          <div class="chip panel">FRAGS<br><b id="frags">0</b></div>
          <div class="chip panel">HEAT<br><b id="heat">0%</b></div>
          <div class="chip panel">TIME<br><b id="timeOfDay">DAY</b></div>
        </div>
      </div>

      <div id="centerWrap">
        <div id="card" class="panel">
          <div id="logo">NEON&nbsp;ALLEY</div>
          <div id="sub">OVERWORLD // NPCs // FRONTLINE</div>
          <p id="desc">
            Steuerung: Ziehen auf der Stadt = bewegen. Tap/Klick auf Nodes = Interaktion.<br>
            <span style="color:var(--muted)">Mobile-Fix: UI liegt über dem Canvas, Buttons bleiben klickbar.</span>
          </p>

          <div class="row">
            <button id="btnEnter" class="btn yellow">ENTER NIGHT CITY</button>
            <button id="btnLoad" class="btn">LOAD SAVE</button>
            <button id="btnReset" class="btn pink">RESET</button>
          </div>

          <div id="log">LOG: <span id="logText">ready…</span></div>
        </div>
      </div>

      <div id="overworld" class="panel">
        <h3>OVERWORLD // ROUTE NODES</h3>
        <div class="tiny">
          Tippe Nodes in der Karte. Jede Interaktion gibt Story-Fragmente + kleine Upgrades.
        </div>
        <div class="row" style="justify-content:flex-start; margin-top:10px;">
          <button id="btnFocus" class="btn">FOCUS</button>
          <button id="btnExport" class="btn">EXPORT</button>
          <button id="btnImport" class="btn">IMPORT</button>
        </div>
        <div class="tiny" style="margin-top:10px;">
          Save JSON wird als Datei heruntergeladen (Export) – Import liest eine Datei ein.
        </div>
      </div>

      <div id="npcPanel" class="panel pink">
        <h3>NPC // DIALOG</h3>
        <div id="npcText">Tippe einen Node, um mit NYX oder GHOST zu interagieren.</div>
        <div class="row" style="justify-content:flex-start; margin-top:10px;">
          <button id="btnCallNyx" class="btn">CALL NYX</button>
          <button id="btnPingGhost" class="btn pink">PING GHOST</button>
        </div>
      </div>

      <div id="footerBar" class="panel pink">
        <div id="quote">
          <b>NYX:</b> “Choom. Overworld first. Dann Frontline. Und wenn Arasaka aufwacht… rennen wir nicht. Wir lenken.”
        </div>
        <div id="footerBtns">
          <button id="btnHelp" class="btn">HELP</button>
        </div>
      </div>

      <div id="toast"></div>
    </div>
  </div>

  <script type="module">
    // ===== PWA: Service Worker (wenn sw.js existiert) =====
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("./sw.js").catch(()=>{});
      });
    }

    // ===== State =====
    const state = {
      money: 0,
      frags: 0,
      heat: 0,
      time: "DAY",
      camera: { x: 0, y: 0, zoom: 1 },
      focused: false,
      nodes: [
        { id:"N1", x:-220, y:-80, name:"Neon Gate", npc:"NYX", text:"Die Stadt atmet – aber nur durch Filter. Du hörst das Summen." },
        { id:"N2", x:  40, y:-30, name:"Alley Market", npc:"GHOST", text:"Ein Händler ohne Gesicht. Er verkauft Erinnerungen in Glas." },
        { id:"N3", x: 190, y: 110, name:"Skyline Relay", npc:"NYX", text:"Du siehst Drohnenlinien. Etwas scannt dich – kurz, dann still." },
        { id:"N4", x:-60, y: 160, name:"Rust Dock", npc:"GHOST", text:"Metall, Wasser, Strom. Jemand hat eine Spur aus Licht gelegt." },
      ],
      selected: null,
    };

    // ===== UI refs =====
    const $ = (id) => document.getElementById(id);
    const moneyEl = $("money");
    const fragsEl = $("frags");
    const heatEl  = $("heat");
    const timeEl  = $("timeOfDay");
    const logText = $("logText");

    const card = $("card");
    const overworld = $("overworld");
    const npcPanel = $("npcPanel");
    const npcText = $("npcText");
    const toast = $("toast");

    // Buttons
    const btnEnter = $("btnEnter");
    const btnLoad  = $("btnLoad");
    const btnReset = $("btnReset");
    const btnFocus = $("btnFocus");
    const btnExport = $("btnExport");
    const btnImport = $("btnImport");
    const btnCallNyx = $("btnCallNyx");
    const btnPingGhost = $("btnPingGhost");
    const btnHelp = $("btnHelp");

    function setLog(msg){ logText.textContent = msg; }
    function showToast(msg){
      toast.textContent = msg;
      toast.style.display = "block";
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=> toast.style.display="none", 1600);
    }

    function renderHUD(){
      moneyEl.textContent = `E$ ${state.money}`;
      fragsEl.textContent = `${state.frags}`;
      heatEl.textContent = `${state.heat}%`;
      timeEl.textContent = state.time;
    }
    renderHUD();

    // ===== Canvas Overworld =====
    const canvas = $("worldCanvas");
    const ctx = canvas.getContext("2d");

    function resize(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    function fit(){
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      resize();
    }
    fit();
    window.addEventListener("resize", resize);

    function worldToScreen(wx, wy){
      const cx = canvas.clientWidth/2;
      const cy = canvas.clientHeight/2;
      return {
        x: cx + (wx - state.camera.x) * state.camera.zoom,
        y: cy + (wy - state.camera.y) * state.camera.zoom
      };
    }
    function screenToWorld(sx, sy){
      const cx = canvas.clientWidth/2;
      const cy = canvas.clientHeight/2;
      return {
        x: (sx - cx)/state.camera.zoom + state.camera.x,
        y: (sy - cy)/state.camera.zoom + state.camera.y
      };
    }

    function draw(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);

      // grid glow
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = "rgba(0,243,255,.25)";
      const step = 70 * state.camera.zoom;
      for(let x = (w/2 - state.camera.x*state.camera.zoom)%step; x < w; x += step){
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
      }
      for(let y = (h/2 - state.camera.y*state.camera.zoom)%step; y < h; y += step){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
      }
      ctx.restore();

      // links
      ctx.save();
      ctx.strokeStyle = "rgba(0,243,255,.18)";
      ctx.lineWidth = 2;
      for(let i=0;i<state.nodes.length-1;i++){
        const a = worldToScreen(state.nodes[i].x, state.nodes[i].y);
        const b = worldToScreen(state.nodes[i+1].x, state.nodes[i+1].y);
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
      }
      ctx.restore();

      // nodes
      for(const n of state.nodes){
        const p = worldToScreen(n.x, n.y);
        const r = 16;
        const selected = state.selected && state.selected.id === n.id;

        // halo
        ctx.save();
        ctx.globalAlpha = selected ? 0.65 : 0.35;
        ctx.fillStyle = n.npc === "NYX" ? "rgba(0,243,255,.8)" : "rgba(255,0,124,.8)";
        ctx.beginPath(); ctx.arc(p.x,p.y,r+8,0,Math.PI*2); ctx.fill();
        ctx.restore();

        // core
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.55)";
        ctx.strokeStyle = n.npc === "NYX" ? "rgba(0,243,255,.9)" : "rgba(255,0,124,.9)";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.restore();

        // label
        ctx.save();
        ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue("--font");
        ctx.fillStyle = "rgba(207,224,235,.92)";
        ctx.fillText(n.id + " · " + n.name, p.x + 22, p.y + 4);
        ctx.restore();
      }

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);

    // ===== Interaction (Drag + Tap) =====
    let dragging = false;
    let last = {x:0,y:0};

    function onDown(e){
      dragging = true;
      const p = pointer(e);
      last.x = p.x; last.y = p.y;
    }
    function onMove(e){
      if(!dragging) return;
      const p = pointer(e);
      const dx = (p.x - last.x) / state.camera.zoom;
      const dy = (p.y - last.y) / state.camera.zoom;
      state.camera.x -= dx;
      state.camera.y -= dy;
      last.x = p.x; last.y = p.y;
    }
    function onUp(e){
      if(!dragging) return;
      dragging = false;

      // Tap = wenn Bewegung klein war
      const p = pointer(e);
      const dist = Math.hypot(p.x-last.x, p.y-last.y);
      if(dist < 8){
        hitTest(p.x, p.y);
      }
    }
    function pointer(e){
      const r = canvas.getBoundingClientRect();
      const t = e.touches && e.touches[0] ? e.touches[0] : null;
      const c = t || e;
      return { x: c.clientX - r.left, y: c.clientY - r.top };
    }

    function hitTest(sx, sy){
      const wpos = screenToWorld(sx, sy);
      let best = null;
      let bestD = 99999;
      for(const n of state.nodes){
        const d = Math.hypot(wpos.x - n.x, wpos.y - n.y);
        if(d < 30 && d < bestD){ best = n; bestD = d; }
      }
      if(!best) return;

      state.selected = best;
      state.frags += 1;
      state.money += 15;
      state.heat = Math.min(100, state.heat + 2);
      renderHUD();

      npcText.innerHTML =
        `<b>${best.npc}</b> @ <span style="color:var(--cyan)">${best.name}</span><br><br>${best.text}<br><br>
         <span style="color:var(--muted)">+1 Frag, +15 Eddies, +2% Heat</span>`;
      showToast(`Node ${best.id} — ${best.name}`);
      setLog(`interacted: ${best.id}`);
    }

    canvas.addEventListener("pointerdown", onDown, {passive:true});
    canvas.addEventListener("pointermove", onMove, {passive:true});
    canvas.addEventListener("pointerup", onUp, {passive:true});
    canvas.addEventListener("pointercancel", onUp, {passive:true});

    // ===== Menu flow =====
    let inGame = false;
    function enterCity(){
      inGame = true;
      card.style.display = "none";
      overworld.style.display = "block";
      npcPanel.style.display = "block";
      setLog("entered overworld");
      showToast("Welcome to Sector-07");
    }

    btnEnter.addEventListener("click", (e)=>{ e.preventDefault(); enterCity(); });
    btnHelp.addEventListener("click", ()=> showToast("Drag = bewegen · Tap auf Nodes = Dialog/Rewards"));

    // ===== Save/Load/Reset =====
    function saveData(){
      return {
        v: 1,
        t: Date.now(),
        money: state.money,
        frags: state.frags,
        heat: state.heat,
        time: state.time,
        camera: state.camera,
        selected: state.selected ? state.selected.id : null,
      };
    }
    function applyData(d){
      if(!d) return;
      state.money = +d.money || 0;
      state.frags = +d.frags || 0;
      state.heat  = +d.heat  || 0;
      state.time  = d.time || "DAY";
      state.camera = d.camera || state.camera;
      state.selected = state.nodes.find(n=>n.id===d.selected) || null;
      renderHUD();
      setLog("loaded save");
      showToast("Save loaded");
    }

    btnLoad.addEventListener("click", ()=>{
      const raw = localStorage.getItem("neonAlleySave");
      if(!raw){ showToast("No save found"); return; }
      try{ applyData(JSON.parse(raw)); }
      catch{ showToast("Save corrupted"); }
    });

    btnReset.addEventListener("click", ()=>{
      localStorage.removeItem("neonAlleySave");
      state.money=0; state.frags=0; state.heat=0; state.time="DAY"; state.selected=null;
      state.camera={x:0,y:0,zoom:1};
      renderHUD();
      npcText.textContent = "Tippe einen Node, um mit NYX oder GHOST zu interagieren.";
      setLog("reset");
      showToast("Reset done");
    });

    btnFocus.addEventListener("click", ()=>{
      state.focused = !state.focused;
      state.camera.zoom = state.focused ? 1.25 : 1;
      showToast(state.focused ? "FOCUS: ON" : "FOCUS: OFF");
    });

    btnCallNyx.addEventListener("click", ()=> showToast("NYX: “Keep it clean. Keep it quiet.”"));
    btnPingGhost.addEventListener("click", ()=> showToast("GHOST: “Signal received… maybe.”"));

    btnExport.addEventListener("click", ()=>{
      const data = saveData();
      localStorage.setItem("neonAlleySave", JSON.stringify(data));
      const blob = new Blob([JSON.stringify(data,null,2)], {type:"application/json"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "neonAlleySave.json";
      a.click();
      URL.revokeObjectURL(a.href);
      showToast("Exported save.json");
    });

    btnImport.addEventListener("click", ()=>{
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "application/json";
      input.onchange = async () => {
        const f = input.files?.[0];
        if(!f) return;
        try{
          const text = await f.text();
          const data = JSON.parse(text);
          localStorage.setItem("neonAlleySave", JSON.stringify(data));
          applyData(data);
        }catch{
          showToast("Import failed");
        }
      };
      input.click();
    });

    // Auto-save every 15s when in game
    setInterval(()=>{
      if(!inGame) return;
      localStorage.setItem("neonAlleySave", JSON.stringify(sa
