<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#05070a" />
  <title>NEON ALLEY</title>

  <!-- PWA optional (wenn vorhanden) -->
  <link rel="manifest" href="./manifest.webmanifest">

  <style>
    :root{
      --bg:#05070a;
      --panel:rgba(8,12,18,.88);
      --cyan:#00f3ff;
      --pink:#ff007c;
      --yellow:#fcee0a;
      --muted:#8aa0b3;
      --line:rgba(0,243,255,.18);
      --shadowC:0 0 18px rgba(0,243,255,.25);
      --shadowP:0 0 18px rgba(255,0,124,.20);
      --font: ui-monospace, SFMono-Regular, Menlo, Consolas, "Courier New", monospace;
    }

    html, body { height:100%; margin:0; background:var(--bg); color:#fff; font-family:var(--font); overflow:hidden; }
    * { box-sizing:border-box; -webkit-tap-highlight-color:transparent; }

    /* LAYERING: Canvas unten, UI oben */
    #app { position:relative; width:100%; height:100%; }
    canvas { position:absolute; inset:0; display:block; z-index:1; touch-action:none; }
    #ui { position:absolute; inset:0; z-index:10; pointer-events:none; } /* ui container klickt NICHT */
    /* Aber einzelne UI-Elemente dürfen klicken: */
    #ui .clickable { pointer-events:auto; }

    /* hübsches UI */
    #hudTop {
      position:absolute; top:12px; left:12px; right:12px;
      display:flex; gap:10px; align-items:stretch;
    }
    .panel {
      background:linear-gradient(180deg, rgba(10,16,24,.92), rgba(5,9,14,.92));
      border:1px solid rgba(0,243,255,.28);
      box-shadow:var(--shadowC);
      padding:10px 12px;
    }
    #district { flex:1; min-width:0; }
    #district .label { font-size:11px; color:var(--muted); letter-spacing:1px; }
    #district .value { font-size:14px; font-weight:800; margin-top:2px; }
    #stats { display:flex; gap:10px; }
    .stat { min-width:76px; text-align:center; }
    .stat .k { font-size:11px; color:var(--muted); letter-spacing:1px; }
    .stat .v { margin-top:2px; font-weight:900; }

    #centerCard {
      position:absolute; left:50%; top:52%;
      transform:translate(-50%,-50%);
      width:min(720px, 92vw);
      padding:16px;
    }
    #titleRow{
      display:flex; align-items:center; justify-content:center;
      margin-bottom:8px;
    }
    #logo{
      font-size:34px; font-weight:900; letter-spacing:6px;
      color:var(--cyan);
      text-shadow:0 0 22px rgba(0,243,255,.35);
    }
    #sub{
      text-align:center;
      color:rgba(255,0,124,.85);
      font-size:12px;
      letter-spacing:3px;
      margin-bottom:10px;
    }
    #desc{
      color:#cfe0eb;
      font-size:12px;
      line-height:1.6;
      margin:10px 0 14px;
    }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
    .btn{
      pointer-events:auto;
      border:1px solid rgba(0,243,255,.55);
      color:var(--cyan);
      background:rgba(0,0,0,.25);
      padding:10px 12px;
      font-weight:900;
      letter-spacing:2px;
      text-transform:uppercase;
      cursor:pointer;
      user-select:none;
      box-shadow:0 0 12px rgba(0,243,255,.12);
    }
    .btn:active { transform:translateY(1px); }
    .btn.yellow { border-color:rgba(252,238,10,.55); color:var(--yellow); box-shadow:0 0 12px rgba(252,238,10,.12); }
    .btn.pink { border-color:rgba(255,0,124,.55); color:var(--pink); box-shadow:0 0 12px rgba(255,0,124,.12); }

    #log {
      margin-top:12px;
      padding-top:10px;
      border-top:1px solid rgba(0,243,255,.16);
      color:var(--muted);
      font-size:12px;
      white-space:pre-wrap;
      min-height:18px;
    }

    #bottomBar {
      position:absolute; left:12px; right:12px; bottom:12px;
      display:flex; gap:10px; align-items:center;
    }
    #quote { flex:1; min-width:0; border:1px solid rgba(255,0,124,.18); box-shadow:var(--shadowP); }
    #quote span { color:rgba(255,255,255,.85); font-size:12px; }
    #actions { display:flex; gap:10px; }

    /* optional: kleines Raster/Scanlines */
    #ui::before{
      content:"";
      position:absolute; inset:0;
      background:
        repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0 1px, transparent 2px 5px);
      opacity:.18;
      pointer-events:none;
      mix-blend-mode:screen;
    }
  </style>
</head>

<body>
  <div id="app">
    <canvas id="threeCanvas"></canvas>

    <div id="ui">
      <div id="hudTop" class="clickable">
        <div id="district" class="panel">
          <div class="label">DISTRICT</div>
          <div class="value" id="districtName">Sector-07</div>
        </div>

        <div id="stats">
          <div class="panel stat">
            <div class="k">EDDIES</div>
            <div class="v" id="money">E$ 0</div>
          </div>
          <div class="panel stat">
            <div class="k">FRAGS</div>
            <div class="v" id="frags">0</div>
          </div>
          <div class="panel stat">
            <div class="k">HEAT</div>
            <div class="v" id="heat">0%</div>
          </div>
          <div class="panel stat">
            <div class="k">TIME</div>
            <div class="v" id="time">DAY</div>
          </div>
        </div>
      </div>

      <div id="centerCard" class="panel clickable">
        <div id="titleRow">
          <div id="logo">NEON&nbsp;ALLEY</div>
        </div>
        <div id="sub">OVERWORLD // NPCs // FRONTLINE</div>

        <div id="desc">
          Steuerung: Ziehen auf der Stadt = bewegen. Tap auf Nodes = Interaktion.<br>
          Wichtig: UI-Buttons müssen auf Mobile immer klickbar bleiben — dieser Build erzwingt das.
        </div>

        <div class="btnRow">
          <button class="btn yellow" id="btnEnter" type="button">ENTER NIGHT CITY</button>
          <button class="btn" id="btnLoad" type="button">LOAD SAVE</button>
          <button class="btn pink" id="btnReset" type="button">RESET</button>
        </div>

        <div id="log">LOG: ready…</div>
      </div>

      <div id="bottomBar" class="clickable">
        <div id="quote" class="panel">
          <span><b>NYX:</b> “Choom. Overworld first. Dann Frontline. Und wenn Arasaka aufwacht… rennen wir nicht. Wir lenken.”</span>
        </div>
        <div id="actions">
          <button class="btn" id="btnNyx" type="button">CALL NYX</button>
          <button class="btn pink" id="btnGhost" type="button">PING GHOST</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "./three.module.js";

    // ---------------------------
    // 1) UI: GARANTIERT klickbar
    // ---------------------------
    const logEl = document.getElementById("log");
    const log = (s) => (logEl.textContent = "LOG: " + s);

    const btnEnter = document.getElementById("btnEnter");
    const btnLoad  = document.getElementById("btnLoad");
    const btnReset = document.getElementById("btnReset");
    const btnNyx   = document.getElementById("btnNyx");
    const btnGhost = document.getElementById("btnGhost");

    btnEnter.addEventListener("click", () => {
      state.mode = "overworld";
      log("Entering Night City… (overworld mode)");
    });

    btnLoad.addEventListener("click", () => {
      const raw = localStorage.getItem("neonalley_save");
      if (!raw) return log("No save found.");
      try {
        const data = JSON.parse(raw);
        state.cameraZ = data.cameraZ ?? state.cameraZ;
        log("Save loaded.");
      } catch {
        log("Save corrupted.");
      }
    });

    btnReset.addEventListener("click", () => {
      localStorage.removeItem("neonalley_save");
      state.cameraZ = 6;
      state.mode = "menu";
      log("Reset done.");
    });

    btnNyx.addEventListener("click", () => log("NYX: Channel open."));
    btnGhost.addEventListener("click", () => log("GHOST: ping sent."));

    // ---------------------------
    // 2) THREE: Canvas Input NUR fürs Canvas
    //    (kein document-level preventDefault!)
    // ---------------------------
    const canvas = document.getElementById("threeCanvas");

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x05070a, 6, 20);

    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 100);
    camera.position.set(0, 2.5, 6);

    const lightA = new THREE.DirectionalLight(0x88ffff, 1.2);
    lightA.position.set(2, 6, 3);
    scene.add(lightA);

    const lightB = new THREE.AmbientLight(0x223344, 0.8);
    scene.add(lightB);

    // simple "city floor" placeholder
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(40, 40, 20, 20),
      new THREE.MeshStandardMaterial({ color: 0x061018, metalness: 0.2, roughness: 0.8 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    scene.add(floor);

    // a few neon "nodes"
    const nodes = [];
    const nodeMat = new THREE.MeshStandardMaterial({ color: 0x00f3ff, emissive: 0x00f3ff, emissiveIntensity: 1.2 });
    for (let i = 0; i < 8; i++) {
      const m = new THREE.Mesh(new THREE.SphereGeometry(0.18, 18, 18), nodeMat);
      m.position.set((Math.random() - 0.5) * 8, 0.25, (Math.random() - 0.5) * 8);
      scene.add(m);
      nodes.push(m);
    }

    // resize
    function resize() {
      const w = canvas.clientWidth || window.innerWidth;
      const h = canvas.clientHeight || window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize, { passive: true });
    resize();

    // state + input
    const state = {
      mode: "menu",
      dragging: false,
      lastX: 0,
      lastY: 0,
      yaw: 0,
      pitch: 0.0,
      cameraZ: 6,
    };

    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();

    // CRITICAL: Events nur auf canvas, und preventDefault nur dort.
    // Außerdem pointer events statt touch/mouse mix.
    canvas.addEventListener("pointerdown", (e) => {
      // UI Buttons liegen über dem canvas und bekommen Events -> also kommt pointerdown hier nur,
      // wenn man wirklich auf den Canvas tippt.
      e.preventDefault();
      canvas.setPointerCapture(e.pointerId);

      state.dragging = true;
      state.lastX = e.clientX;
      state.lastY = e.clientY;

      // click/select node
      const rect = canvas.getBoundingClientRect();
      ndc.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      ndc.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(nodes, false);
      if (hits.length) {
        const idx = nodes.indexOf(hits[0].object);
        log("Node tapped: #" + (idx + 1));
      }
    }, { passive: false });

    canvas.addEventListener("pointermove", (e) => {
      if (!state.dragging) return;
      e.preventDefault();

      const dx = e.clientX - state.lastX;
      const dy = e.clientY - state.lastY;
      state.lastX = e.clientX;
      state.lastY = e.clientY;

      state.yaw -= dx * 0.004;
      state.pitch = THREE.MathUtils.clamp(state.pitch - dy * 0.003, -0.35, 0.35);
    }, { passive: false });

    function endDrag(e){
      if (!state.dragging) return;
      e.preventDefault();
      state.dragging = false;
      try { canvas.releasePointerCapture(e.pointerId); } catch {}
    }
    canvas.addEventListener("pointerup", endDrag, { passive: false });
    canvas.addEventListener("pointercancel", endDrag, { passive: false });

    // animate
    function tick(t) {
      requestAnimationFrame(tick);

      // subtle node pulse
      const tt = t * 0.001;
      for (let i = 0; i < nodes.length; i++) {
        nodes[i].position.y = 0.25 + Math.sin(tt * 2 + i) * 0.03;
      }

      // camera orbit-ish
      const r = state.cameraZ;
      camera.position.x = Math.sin(state.yaw) * r;
      camera.position.z = Math.cos(state.yaw) * r;
      camera.position.y = 2.4 + state.pitch * 3.0;
      camera.lookAt(0, 0.2, 0);

      renderer.render(scene, camera);
    }
    requestAnimationFrame(tick);

    // save helper (optional)
    window.addEventListener("beforeunload", () => {
      localStorage.setItem("neonalley_save", JSON.stringify({ cameraZ: state.cameraZ }));
    });

    // PWA SW (optional)
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("./sw.js").catch(()=>{});
    }
  </script>
</body>
</html>
