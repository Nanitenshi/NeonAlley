<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<title>NEON ALLEY // FRONTLINE ARCADE</title>

<!-- PWA -->
<link rel="manifest" href="./manifest.webmanifest">
<meta name="theme-color" content="#00f3ff">

<style>
  :root{
    --bg:#04060a;
    --cyan:#00f3ff;
    --pink:#ff007c;
    --yellow:#fcee0a;
    --orange:#ff8a00;
    --muted:#9fb3c2;
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{margin:0;height:100%;background:var(--bg);overflow:hidden;font-family:ui-monospace,Menlo,Consolas,"Courier New",monospace;color:#fff}
  canvas{position:fixed;inset:0;display:block}
  #fx{pointer-events:none}
  #scan{
    position:fixed;inset:0;pointer-events:none;z-index:60;
    background:repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0 1px, transparent 2px 4px);
    opacity:.30;mix-blend-mode:screen;
  }

  #ui{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    background:radial-gradient(circle at 50% 35%, rgba(0,243,255,.08), transparent 45%), rgba(0,0,0,.65);
    z-index:50;
    pointer-events:auto;
  }
  .panel{
    width:min(680px,92vw);
    padding:18px;
    border:1px solid rgba(0,243,255,.35);
    background:linear-gradient(180deg, rgba(0,10,18,.75), rgba(0,0,0,.60));
    box-shadow:0 0 22px rgba(0,243,255,.18);
    clip-path:polygon(0 0, calc(100% - 16px) 0, 100% 16px, 100% 100%, 16px 100%, 0 calc(100% - 16px));
  }
  h1{margin:0 0 6px 0;letter-spacing:6px;color:var(--cyan);text-shadow:0 0 16px rgba(0,243,255,.6)}
  .sub{font-size:11px;color:rgba(255,255,255,.7);letter-spacing:2px;margin-bottom:12px}
  .btn{
    width:100%;padding:14px 12px;margin-top:10px;
    border:1px solid rgba(0,243,255,.7);background:rgba(0,0,0,.22);color:var(--cyan);
    font-weight:900;letter-spacing:2px;text-transform:uppercase;
    touch-action:manipulation;
    cursor:pointer;
  }
  .btn:active{background:rgba(0,243,255,.18)}

  #hud{
    position:fixed;left:10px;right:10px;top:10px;z-index:40;
    display:none;gap:8px;flex-wrap:wrap;pointer-events:none;
  }
  .box{
    flex:1;min-width:150px;padding:8px 10px;border:1px solid rgba(0,243,255,.22);
    background:rgba(0,0,0,.35);
  }
  .lab{font-size:10px;color:var(--muted);letter-spacing:1px}
  .val{font-size:13px;font-weight:900}

  #bar{
    position:fixed;left:10px;right:10px;bottom:10px;z-index:45;
    display:none;gap:8px;flex-wrap:wrap;
    pointer-events:auto;
  }
  .skill{
    flex:1;min-width:150px;
    padding:12px 10px;border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.40);color:#fff;font-weight:900;letter-spacing:1px;
    touch-action:manipulation;
    cursor:pointer;
  }
  .skill.cyan{border-color:rgba(0,243,255,.55);color:var(--cyan)}
  .skill.pink{border-color:rgba(255,0,124,.55);color:var(--pink)}
  .skill.yellow{border-color:rgba(252,238,10,.55);color:var(--yellow)}
  .skill:active{transform:scale(.99)}

  .hint{
    position:fixed;left:10px;bottom:68px;z-index:46;
    font-size:11px;color:rgba(220,235,245,.85);
    background:rgba(0,0,0,.40);border:1px solid rgba(255,255,255,.08);
    padding:8px 10px;display:none;
    pointer-events:none;
  }
</style>
</head>
<body>

<canvas id="c"></canvas>
<canvas id="fx"></canvas>
<div id="scan"></div>

<div id="hud">
  <div class="box"><div class="lab">MODE</div><div class="val">FRONTLINE // ARCADE</div></div>
  <div class="box"><div class="lab">FRONT</div><div class="val" id="hudFront">50%</div></div>
  <div class="box"><div class="lab">TIME</div><div class="val" id="hudTime">70s</div></div>
  <div class="box"><div class="lab">RAM</div><div class="val" id="hudRam">0</div></div>
</div>

<div id="bar">
  <button class="skill cyan" id="btnPulse" type="button">PULSE (Tap)</button>
  <button class="skill yellow" id="btnBeam" type="button">HACK BEAM (Hold)</button>
  <button class="skill pink" id="btnEMP" type="button">EMP (Ult)</button>
  <button class="skill" id="btnQuit" type="button">QUIT</button>
</div>

<div class="hint" id="hint">Tap = Pulse. Hold & drag = Hack Beam. EMP = Panic Button.</div>

<div id="ui">
  <div class="panel">
    <h1>NEON ALLEY</h1>
    <div class="sub">BREACH VERWORFEN // ARCADE FRONTLINE (B)</div>
    <div style="font-size:12px;line-height:1.45;color:rgba(230,240,250,.92)">
      <b>Push die Front</b> bis Arasaka rechts fällt. Keine Build-Orgien – du spielst aktiv:
      <br>• <b>Pulse</b> (Tap) räumt Gegner an der Front.
      <br>• <b>Hack Beam</b> (halten/ziehen) schmilzt Gegner & „zieht“ die Linie kurz zu dir.
      <br>• <b>EMP</b> ist dein Ult: Reset gegnerischer Push.
    </div>
    <button class="btn" id="btnStart" type="button">ENTER NIGHT CITY</button>
    <div style="margin-top:10px;font-size:11px;color:rgba(255,255,255,.65)">
      Tipp: Spiele aggressiv. Pulse off-cooldown, Beam nur wenn Arasaka drückt.
    </div>
  </div>
</div>

<script>
/* PWA Service Worker */
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("./sw.js").catch(()=>{});
}

/* Canvas */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const fx = document.getElementById("fx");
const fctx = fx.getContext("2d");

/* UI */
const ui = document.getElementById("ui");
const hud = document.getElementById("hud");
const bar = document.getElementById("bar");
const hint = document.getElementById("hint");

const hudFront = document.getElementById("hudFront");
const hudTime  = document.getElementById("hudTime");
const hudRam   = document.getElementById("hudRam");

const btnStart = document.getElementById("btnStart");
const btnPulse = document.getElementById("btnPulse");
const btnBeam  = document.getElementById("btnBeam");
const btnEMP   = document.getElementById("btnEMP");
const btnQuit  = document.getElementById("btnQuit");

function resize(){
  canvas.width = fx.width = innerWidth;
  canvas.height = fx.height = innerHeight;
}
addEventListener("resize", resize);
resize();

/* Helpers */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand=(a,b)=>a+Math.random()*(b-a);

/* Game State */
const G = {
  running:false,
  w:()=>canvas.width,
  h:()=>canvas.height,
  front:0.50,
  timeLeft:70,
  progress:0,
  ram:50,
  ramMax:100,
  ramRegen:26,
  cdPulse:0,
  cdEmp:0,
  mode:"pulse",
  unitsP:[],
  unitsE:[],
  spawnT:0,
  tick:0,
  beaming:false,
  beamX:0,
  beamY:0,
};

function resetRun(){
  G.front = 0.50;
  G.timeLeft = 70;
  G.progress = 0;
  G.ram = 50;
  G.cdPulse = 0;
  G.cdEmp = 0;
  G.unitsP.length = 0;
  G.unitsE.length = 0;
  G.spawnT = 0;
  G.tick = 0;
  G.beaming = false;
}

function spawn(side){
  const isP = side==="P";
  const x = isP ? 40 : (G.w()-40);
  const y = 120 + Math.random()*(G.h()-240);
  const speed = isP ? rand(70,110) : rand(75,130);
  const hp = isP ? rand(10,16) : rand(12,18);
  const power = isP ? rand(1.0,1.6) : rand(1.0,1.9);
  (isP?G.unitsP:G.unitsE).push({x,y,speed,hp,power,r:10});
}

/* FX rings */
const rings=[];
function burstFX(x,y,r,color){
  rings.push({x,y,r,t:0,color});
}
function drawRings(dt){
  for(const ring of rings) ring.t += dt;
  for(let i=rings.length-1;i>=0;i--) if(rings[i].t>0.5) rings.splice(i,1);
  for(const ring of rings){
    const p = ring.t/0.5;
    const rr = ring.r*(0.3+p*0.9);
    ctx.globalAlpha = 0.35*(1-p);
    ctx.lineWidth = 3;
    ctx.strokeStyle = ring.color==="pink" ? "rgba(255,0,124,0.95)" : "rgba(0,243,255,0.95)";
    ctx.beginPath(); ctx.arc(ring.x, ring.y, rr, 0, Math.PI*2); ctx.stroke();
    ctx.globalAlpha = 1;
  }
}

/* Skills */
function doPulse(x,y){
  if(G.cdPulse>0) return;
  const cost = 12;
  if(G.ram < cost) return;
  G.ram -= cost;
  G.cdPulse = 0.55;

  const R = 130;
  for(const u of G.unitsE){
    const d = Math.hypot(u.x-x, u.y-y);
    if(d < R) u.hp -= (3.8 * (1 - d/R));
  }
  G.front = clamp(G.front + 0.010, 0.06, 0.94);
  burstFX(x,y,R,"cyan");
}

function doEMP(){
  if(G.cdEmp>0) return;
  const cost = 70;
  if(G.ram < cost) return;
  G.ram -= cost;
  G.cdEmp = 18;

  const frontX = G.front * G.w();
  G.unitsE = G.unitsE.filter(u => Math.abs(u.x-frontX) > 380);
  G.front = clamp(G.front + 0.04, 0.06, 0.94);
  burstFX(frontX, G.h()*0.5, 300, "pink");
}

function beamApply(dt){
  const costPerSec = 28;
  const need = costPerSec * dt;
  if(G.ram < need){ G.beaming=false; return; }
  G.ram -= need;

  const frontX = G.front * G.w();
  const x = G.beamX, y = G.beamY;

  const R = 220;
  for(const u of G.unitsE){
    const d = Math.hypot(u.x-x, u.y-y);
    if(d < R) u.hp -= (6.2*dt) * (1 - d/R);
  }
  if(Math.abs(x-frontX) < 180) G.front = clamp(G.front + (0.020*dt), 0.06, 0.94);
}

/* Buttons */
btnPulse.addEventListener("click", ()=>G.mode="pulse");
btnBeam.addEventListener("click",  ()=>G.mode="beam");
btnEMP.addEventListener("click", doEMP);
btnQuit.addEventListener("click", stop);

/* Input */
let pointerDown=false;
canvas.addEventListener("pointerdown",(e)=>{
  if(!G.running) return;
  pointerDown=true;
  if(G.mode==="pulse") doPulse(e.clientX, e.clientY);
  else { G.beaming=true; G.beamX=e.clientX; G.beamY=e.clientY; }
},{passive:true});

addEventListener("pointermove",(e)=>{
  if(!G.running || !pointerDown) return;
  if(G.mode==="beam"){ G.beamX=e.clientX; G.beamY=e.clientY; }
},{passive:true});

addEventListener("pointerup",()=>{
  pointerDown=false;
  G.beaming=false;
},{passive:true});

/* Draw */
function drawFront(){
  const x0 = G.front * G.w();
  const step = 22;

  const gradL = ctx.createLinearGradient(0,0,x0,0);
  gradL.addColorStop(0, "rgba(0,243,255,0.12)");
  gradL.addColorStop(1, "rgba(0,243,255,0.02)");
  ctx.fillStyle = gradL; ctx.fillRect(0,0,x0,G.h());

  const gradR = ctx.createLinearGradient(x0,0,G.w(),0);
  gradR.addColorStop(0, "rgba(255,138,0,0.03)");
  gradR.addColorStop(1, "rgba(255,0,124,0.10)");
  ctx.fillStyle = gradR; ctx.fillRect(x0,0,G.w()-x0,G.h());

  ctx.beginPath(); ctx.moveTo(x0,0);
  let y=0, dir=1;
  while(y < G.h()){
    const n = Math.sin((y*0.03)+G.tick*0.9)*10;
    const j = (dir*10)+n;
    ctx.lineTo(x0+j, y+step);
    y += step; dir *= -1;
  }
  ctx.shadowBlur=18; ctx.shadowColor="rgba(255,255,255,0.55)";
  ctx.strokeStyle="rgba(255,255,255,0.7)"; ctx.lineWidth=3; ctx.stroke();
  ctx.shadowBlur=0;

  ctx.fillStyle="rgba(0,243,255,0.85)"; ctx.fillRect(18, G.h()*0.5-42, 10, 84);
  ctx.fillStyle="rgba(255,0,124,0.85)"; ctx.fillRect(G.w()-28, G.h()*0.5-42, 10, 84);
}

function drawUnits(){
  for(const u of G.unitsP){
    ctx.beginPath(); ctx.arc(u.x,u.y,u.r,0,Math.PI*2);
    ctx.strokeStyle="rgba(0,243,255,0.95)"; ctx.lineWidth=2; ctx.stroke();
    ctx.globalAlpha=0.14; ctx.fillStyle="rgba(0,243,255,0.7)"; ctx.fill(); ctx.globalAlpha=1;
  }
  for(const u of G.unitsE){
    ctx.beginPath(); ctx.arc(u.x,u.y,u.r,0,Math.PI*2);
    ctx.strokeStyle="rgba(255,138,0,0.95)"; ctx.lineWidth=2; ctx.stroke();
    ctx.globalAlpha=0.12; ctx.fillStyle="rgba(255,0,124,0.6)"; ctx.fill(); ctx.globalAlpha=1;
  }
}

function drawBeam(){
  if(!G.beaming) return;
  ctx.shadowBlur = 18;
  ctx.shadowColor = "rgba(252,238,10,0.35)";
  ctx.lineWidth = 6;
  ctx.strokeStyle = "rgba(252,238,10,0.85)";
  ctx.beginPath();
  ctx.moveTo(30, G.h()*0.5);
  ctx.lineTo(G.beamX, G.beamY);
  ctx.stroke();
  ctx.shadowBlur = 0;

  ctx.beginPath();
  ctx.arc(G.beamX, G.beamY, 18, 0, Math.PI*2);
  ctx.strokeStyle="rgba(252,238,10,0.85)";
  ctx.lineWidth=2;
  ctx.stroke();
}

function drawFX(){
  fctx.clearRect(0,0,G.w(),G.h());
  const p = G.progress;

  const g = fctx.createRadialGradient(G.w()/2,G.h()*0.45,G.w()*0.2,G.w()/2,G.h()*0.45,G.w()*0.85);
  g.addColorStop(0,"rgba(0,0,0,0)");
  g.addColorStop(1,"rgba(0,0,0,0.65)");
  fctx.fillStyle=g; fctx.fillRect(0,0,G.w(),G.h());

  for(let i=0;i<26;i++){
    const x=(Math.sin(G.tick*0.25+i)*0.5+0.5)*G.w();
    const y=(Math.cos(G.tick*0.23+i*1.7)*0.5+0.5)*G.h();
    const r=45+(i%7)*16;
    fctx.beginPath();
    fctx.fillStyle=`rgba(255,120,90,${0.015 + p*0.06})`;
    fctx.arc(x,y,r,0,Math.PI*2);
    fctx.fill();
  }
}

/* Loop */
let last=performance.now();
function loop(now){
  if(!G.running) return;
  const dt=Math.min(0.04,(now-last)/1000);
  last=now;
  G.tick += dt;

  G.timeLeft -= dt;
  if(G.timeLeft < 0) G.timeLeft = 0;
  G.progress = clamp(G.progress + dt*0.012, 0, 1);

  G.ram = Math.min(G.ramMax, G.ram + dt*G.ramRegen);

  if(G.cdPulse>0) G.cdPulse = Math.max(0, G.cdPulse-dt);
  if(G.cdEmp>0)   G.cdEmp   = Math.max(0, G.cdEmp-dt);

  G.spawnT += dt;
  const enemyBias = 0.30 + G.progress*0.55;
  if(G.spawnT > 0.35){
    G.spawnT = 0;
    spawn("P");
    if(Math.random() < enemyBias) spawn("E");
    if(Math.random() < enemyBias*0.7) spawn("E");
  }

  if(G.beaming) beamApply(dt);

  const frontX = G.front * G.w();
  for(const u of G.unitsP){
    const dir = (frontX - u.x) > 0 ? 1 : -1;
    u.x += dir * u.speed * dt;
  }
  for(const u of G.unitsE){
    const dir = (frontX - u.x) > 0 ? 1 : -1;
    u.x += dir * u.speed * dt;
  }

  const near=34;
  let pNear=0, eNear=0;

  G.unitsP = G.unitsP.filter(u=>{
    if(u.hp<=0) return false;
    if(Math.abs(u.x-frontX) < near){ pNear += u.power; u.hp -= 6.5*dt; }
    return u.hp>0;
  });
  G.unitsE = G.unitsE.filter(u=>{
    if(u.hp<=0) return false;
    if(Math.abs(u.x-frontX) < near){ eNear += u.power; u.hp -= 6.5*dt; }
    return u.hp>0;
  });

  const biasP = 1.05;
  const biasE = 1.08 + G.progress*0.35;
  const delta = (pNear*biasP - eNear*biasE) * 0.00075;
  G.front = clamp(G.front + delta, 0.06, 0.94);

  if(G.front > 0.92) return end(true);
  if(G.front < 0.08) return end(false);
  if(G.timeLeft <= 0) return end(G.front > 0.50);

  ctx.clearRect(0,0,G.w(),G.h());
  drawFront();
  drawUnits();
  drawBeam();
  drawRings(dt);
  drawFX();

  hudFront.textContent = Math.round(G.front*100) + "%";
  hudTime.textContent  = Math.ceil(G.timeLeft) + "s";
  hudRam.textContent   = Math.floor(G.ram);

  btnPulse.textContent = `PULSE (Tap) • ${G.cdPulse>0 ? G.cdPulse.toFixed(1)+"s" : "READY"} • RAM 12`;
  btnEMP.textContent   = `EMP (Ult) • ${G.cdEmp>0 ? G.cdEmp.toFixed(0)+"s" : "READY"} • RAM 70`;

  requestAnimationFrame(loop);
}

/* Start/Stop */
function start(){
  ui.style.display="none";
  hud.style.display="flex";
  bar.style.display="flex";
  hint.style.display="block";
  G.running=true;
  resetRun();
  last=performance.now();
  requestAnimationFrame(loop);
}
function stop(){
  G.running=false;
  ui.style.display="flex";
  hud.style.display="none";
  bar.style.display="none";
  hint.style.display="none";
}
function end(win){
  G.running=false;
  setTimeout(()=>{
    alert(win ? "NODE TAKEN ✅  (Arasaka pushed back)" : "CONNECTION LOST ❌  (Arasaka overwhelmed you)");
    stop();
  }, 80);
}

btnStart.addEventListener("click", start, {passive:true});
</script>

</body>
        </html>
